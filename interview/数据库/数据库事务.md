# 数据库事务

事务就是要保证一组数据库操作要么全部成功，要么全部失败

不是所有的数据库引擎都支持事务
MyISAM 不支持事务  InnoDB 支持事务

事务具有四个特性 ACID
A 原子性    要么全部成功，要么全部失败
C 一致性    确保一个事务执行之前和执行之后必须处于一致的状态
I 隔离性    一个事务在提交之前是否能够被其他事务可见
D 持久性    如果一旦一个事务提交了，那么这个改变就是永久性的

事务隔离级别具有四种：
1. 读未提交     一个事务还没提交时，其他事务能够看到它做的变更
2. 读提交       一个事务提交之后，其他事务才能看到变更
3. 可重复读     一个事务在执行过程中，看到的数据总是跟这个事务启动时看到的数据一致
4. 串行化       事务不可并行执行，后访问的事务必须等前一个事务完成，才能继续执行

事务的启动方式
1. 显示启动的事务，begin 启动， commit 提交， rollback 回滚
2. 程序会自动提交事务

数据库锁
全局锁 表锁 行锁

全局锁有什么锁，对业务有什么影响，不能做其他操作
对数据库做全局备份，这种情况只针对没有事务特性的引擎
InnoDB怎么做备份
mysqldump 参数 -single transaction, 导出数据前启动一个事务，拿到一致性视图，整个过程中，数据库可以正常更新，业务不受影响

表锁：  手动触发    lock tables...read/write
元数据锁：  自动触发    访问一张表的时候自动触发的

- 读锁： 对于读操作，可以加读锁，一旦数据表加上读锁，不能加写锁，可以多个事务加多个锁

- 写锁：对于写操作，一旦加上了写锁，其他事务无法加上读锁和写锁


行锁： 行锁可以锁一行或者多行记录，InnoDB基于索引实现
行锁的特性：并发性比较高，但是有可能出现死锁，

如果出现死锁怎么办？
- 死锁检测，mysql发现有死锁出现时，主动回滚某一个事务，让其他事务继续运行
- 启动时超时机制

脏读：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。
也就是A事务读取了B事务未提交的数据，如果B事务发生了回滚，那么A事务读取到的数据就是脏数据

幻读：同一个事务前后多次读取，但是数据总量不一样（就是这之间有insert）

不可重复读：A事务在执行的过程中，由于A事务比较大，需要长时间多次读取同一条数据，读取到的数据不一致，A事务无法读取到之前的数据了。（针对updata）